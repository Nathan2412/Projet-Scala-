# SÃ©ance 1 - Introduction Ã  la Programmation Fonctionnelle avec Scala

## ğŸ“š Objectifs d'apprentissage

- DÃ©couvrir Scala et son Ã©cosystÃ¨me
- Comprendre l'immutabilitÃ© (`val` vs `var`)
- Ã‰crire des fonctions pures (sans effets de bord)
- MaÃ®triser les expressions vs instructions
- Travailler avec les types simples de Scala
- Utiliser le pattern matching
- Construire un mini-projet : SystÃ¨me d'Ã‰valuation d'Ã‰tudiants

## ğŸš€ Mise en route

### PrÃ©requis

- Java JDK 11 ou supÃ©rieur
- SBT (Scala Build Tool) installÃ©

### Installation

1. Clonez ou tÃ©lÃ©chargez ce projet
2. Ouvrez un terminal dans le dossier du projet
3. Lancez SBT avec la commande :
   ```bash
   sbt
   ```

### Commandes utiles

Dans le terminal SBT :

- `compile` - Compile le code
- `test` - Lance tous les tests
- `testOnly seance1.ExercicesSpec` - Lance uniquement les tests des exercices
- `console` - Ouvre le REPL Scala pour tester du code interactivement
- `~test` - Mode watch : relance les tests automatiquement Ã  chaque modification

Ou utilisez le script fourni :
```bash
./verifier.sh
```

## ğŸ“ Structure du projet

```
seance-1/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/scala/
â”‚   â”‚   â””â”€â”€ Exercices.scala    # âš ï¸ Fichier Ã  complÃ©ter (vos solutions)
â”‚   â””â”€â”€ test/scala/
â”‚       â””â”€â”€ ExercicesSpec.scala # ğŸ§ª Tests pour valider vos solutions
â”œâ”€â”€ build.sbt                   # Configuration du projet
â””â”€â”€ README.md                   # Ce fichier
```

## ğŸ¯ Instructions pour les exercices

### Ã‰tape 1 : Comprendre les exercices

Ouvrez le fichier `src/main/scala/Exercices.scala` et lisez attentivement :
- Les commentaires expliquant chaque exercice
- Les signatures de fonctions (types d'entrÃ©e et de sortie)
- Les exemples fournis

### Ã‰tape 2 : ComplÃ©ter les fonctions

Remplacez les `???` par votre code. 

**RÃ¨gles importantes :**
- âŒ N'utilisez PAS `var` (variables mutables)
- âœ… Utilisez uniquement `val` (valeurs immutables)
- âœ… PrivilÃ©giez les expressions pures (sans effets de bord)
- âŒ Pas de `println` dans vos fonctions (sauf si explicitement demandÃ©)
- âœ… Utilisez le pattern matching quand c'est appropriÃ©

### Ã‰tape 3 : Tester votre code

Lancez les tests avec :
```bash
sbt test
# ou
./verifier.sh
```

Les tests vous indiqueront :
- âœ… Les exercices rÃ©ussis (en vert)
- âŒ Les exercices Ã  corriger (en rouge avec dÃ©tails)

### Ã‰tape 4 : ItÃ©rer

- Corrigez les erreurs
- Relancez les tests
- RÃ©pÃ©tez jusqu'Ã  ce que tous les tests passent ! ğŸ‰

## ğŸ“– Organisation des exercices

### Partie 1 : Expressions et ImmutabilitÃ© (3 exercices)
**Concepts :** `if/else` comme expression, pas de `return` nÃ©cessaire

**Exercices :**
- `max` : Maximum de deux nombres
- `abs` : Valeur absolue
- `signe` : Identifier si un nombre est positif, nÃ©gatif ou zÃ©ro

### Partie 2 : Types Simples et Typage (4 exercices)
**Concepts :** `Int`, `Double`, `String`, `Boolean`, infÃ©rence de type

**Exercices :**
- `celsiusVersFahrenheit` : Conversion de tempÃ©rature
- `calculerIMC` : Calcul d'Indice de Masse Corporelle
- `ageValide` : Validation d'Ã¢ge
- `nomComplet` : Formatage de chaÃ®nes

### Partie 3 : Fonctions Pures et RÃ©cursion (3 exercices)
**Concepts :** RÃ©cursion, fonctions pures, pas de boucles

**Exercices :**
- `factorielle` : Calcul rÃ©cursif de n!
- `puissance` : Ã‰lÃ©vation Ã  la puissance
- `longueurChaine` : Compter les caractÃ¨res rÃ©cursivement

### Partie 4 : Pattern Matching Simple (3 exercices)
**Concepts :** `match/case`, guards (conditions)

**Exercices :**
- `jourSemaine` : Convertir un nombre en nom de jour
- `noteEnLettre` : Convertir un score en lettre (A, B, C, D, F)
- `categorieAge` : Classifier par catÃ©gorie d'Ã¢ge

### Partie 5 : Types ComposÃ©s - Tuples (3 exercices)
**Concepts :** Tuples, dÃ©structuration, pattern matching sur tuples

**Exercices :**
- `creerPersonne` : CrÃ©er un tuple (nom, age)
- `extraireNom` : Extraire une valeur d'un tuple
- `estMajeur` : VÃ©rifier la majoritÃ© avec pattern matching

### Partie 6 : Mini-Projet - SystÃ¨me d'Ã‰valuation (7 exercices)
**Objectif :** Construire un systÃ¨me complet de gestion de notes d'Ã©tudiants

**Types utilisÃ©s :**
- `Note` : Tuple (matiÃ¨re, score)
- `Ã‰tudiant` : Tuple (nom, note1, note2, note3)

**Exercices progressifs :**
1. `creerEtudiant` : CrÃ©er un Ã©tudiant avec ses notes
2. `noteValide` : Valider une note (0-100)
3. `moyenneTroisScores` : Calculer une moyenne simple
4. `moyenneEtudiant` : Extraire et calculer la moyenne d'un Ã©tudiant
5. `mentionEtudiant` : DÃ©terminer la mention selon la moyenne
6. `rapportEtudiant` : GÃ©nÃ©rer un rapport complet (composition de fonctions)
7. `meilleurEtudiant` : Comparer deux Ã©tudiants

### BONUS : Exercices AvancÃ©s (3 exercices optionnels)
Pour aller plus loin :
- `fibonacci` : Suite de Fibonacci
- `estPalindrome` : VÃ©rifier les palindromes
- `pgcd` : Plus Grand Commun Diviseur (algorithme d'Euclide)

---

## ğŸ’¡ Astuces

### Utiliser le REPL
Le REPL (Read-Eval-Print Loop) est excellent pour tester des idÃ©es :
```bash
sbt console
```

Puis testez vos expressions :
```scala
scala> val x = 5
scala> val y = 3
scala> if (x > y) x else y
// res0: Int = 5

scala> def max(a: Int, b: Int) = if (a > b) a else b
scala> max(10, 20)
// res1: Int = 20
```

### Syntaxes Importantes

**Expression if/else :**
```scala
// âŒ Style impÃ©ratif (Ã  Ã©viter)
var result = 0
if (x > 0) {
  result = x
} else {
  result = -x
}

// âœ… Style fonctionnel (expression)
val result = if (x > 0) x else -x
```

**Pattern Matching :**
```scala
// Sur valeur
jour match {
  case 1 => "Lundi"
  case 2 => "Mardi"
  case _ => "Autre"
}

// Avec guards (conditions)
score match {
  case s if s >= 90 => "A"
  case s if s >= 80 => "B"
  case _ => "F"
}

// Sur tuple (dÃ©structuration)
personne match {
  case (nom, age) => s"$nom a $age ans"
}
```

**Tuples :**
```scala
// CrÃ©ation
val personne = ("Alice", 25)
val point = (10, 20)

// AccÃ¨s
personne._1  // "Alice"
personne._2  // 25

// DÃ©structuration
val (nom, age) = personne
```

**RÃ©cursion :**
```scala
def factorielle(n: Int): Int = {
  if (n <= 0) 1              // Cas de base
  else n * factorielle(n-1)  // Cas rÃ©cursif
}
```

**Interpolation de chaÃ®nes :**
```scala
val nom = "Alice"
val age = 25
s"$nom a $age ans"           // "Alice a 25 ans"
s"Dans 5 ans: ${age + 5}"    // "Dans 5 ans: 30"
```

### Concepts ClÃ©s

#### ImmutabilitÃ©
```scala
val x = 5      // âœ… Immutable - TOUJOURS prÃ©fÃ©rÃ©
var y = 5      // âŒ Mutable - Ã€ Ã‰VITER

// x = 6       // Erreur de compilation !
y = 6          // OK mais non fonctionnel
```

#### Fonctions Pures
Une fonction pure :
- Retourne toujours le mÃªme rÃ©sultat pour les mÃªmes paramÃ¨tres
- N'a pas d'effets de bord (pas de modification d'Ã©tat, pas d'I/O)
- Est prÃ©visible et testable

```scala
// âœ… Fonction pure
def add(a: Int, b: Int): Int = a + b

// âŒ Fonction impure (effet de bord)
def addAndPrint(a: Int, b: Int): Int = {
  val result = a + b
  println(result)  // Effet de bord !
  result
}
```

#### Expressions vs Instructions
En Scala, tout est une expression qui retourne une valeur :

```scala
// if/else est une expression
val max = if (a > b) a else b

// match est une expression
val jour = n match {
  case 1 => "Lundi"
  case 2 => "Mardi"
  case _ => "Autre"
}

// MÃªme un bloc { } est une expression
val result = {
  val x = 10
  val y = 20
  x + y  // DerniÃ¨re ligne = valeur retournÃ©e
}
```

## ğŸ“ Progression SuggÃ©rÃ©e

### Pour DÃ©butants (2-3h)
1. Partie 1 (Expressions)
2. Partie 2 (Types simples)
3. Partie 3 (RÃ©cursion simple : factorielle, puissance)
4. Partie 4 (Pattern matching)

### Pour Niveau IntermÃ©diaire (3-4h)
Tout ce qui prÃ©cÃ¨de, plus :
- Partie 5 (Tuples)
- Partie 6 (Mini-projet exercices 6.1 Ã  6.4)

### Pour Niveau AvancÃ© (4-5h)
Tout, y compris :
- Partie 6 complÃ¨te (Mini-projet)
- Exercices BONUS

## ğŸ“Š Validation

Votre objectif : **faire passer tous les tests** ! 

Lorsque vous verrez ceci, vous aurez rÃ©ussi :
```
[info] ExercicesSpec:
[info] - 1.1 - max: retourne le plus grand de deux nombres âœ“
[info] - 1.2 - abs: retourne la valeur absolue âœ“
[info] ... (tous les tests) âœ“
[info] All tests passed
```

## ğŸ¯ Le Mini-Projet : SystÃ¨me d'Ã‰valuation

Le point culminant de cette sÃ©ance est la **Partie 6**, oÃ¹ vous construirez progressivement un systÃ¨me de gestion de notes.

### Architecture

```
Note = (String, Int)
  â†“
Ã‰tudiant = (String, Note, Note, Note)
  â†“
Fonctions:
  - CrÃ©er un Ã©tudiant
  - Valider les notes
  - Calculer moyennes
  - DÃ©terminer mentions
  - GÃ©nÃ©rer rapports
  - Comparer Ã©tudiants
```

### Exemple d'Utilisation

```scala
// CrÃ©er un Ã©tudiant
val alice = creerEtudiant(
  "Alice",
  ("Math", 85),
  ("Physique", 90),
  ("Chimie", 88)
)

// Calculer sa moyenne
val moyenne = moyenneEtudiant(alice)  // 87.67

// DÃ©terminer sa mention
val mention = mentionEtudiant(moyenne)  // "Bien"

// GÃ©nÃ©rer un rapport
val rapport = rapportEtudiant(alice)
// "Nom: Alice, Moyenne: 87.67, Mention: Bien"
```

Ce mini-projet dÃ©montre :
- âœ… Composition de fonctions
- âœ… Utilisation de types personnalisÃ©s (tuples)
- âœ… Pattern matching pour extraire des donnÃ©es
- âœ… Fonctions pures qui se construisent les unes sur les autres
- âœ… ImmutabilitÃ© totale

## ğŸ¤ Besoin d'aide ?

- Relisez les commentaires dans `Exercices.scala`
- Consultez les exemples dans la section "Astuces"
- Utilisez le REPL pour expÃ©rimenter : `sbt console`
- Lisez les messages d'erreur attentivement
- N'hÃ©sitez pas Ã  demander de l'aide Ã  votre enseignant

### Erreurs Courantes

**"not found: value ???"**
â†’ Vous n'avez pas encore remplacÃ© le `???` par votre code

**"type mismatch"**
â†’ VÃ©rifiez que votre fonction retourne le bon type

**"missing parameter type"**
â†’ Scala a besoin de connaÃ®tre les types des paramÃ¨tres

**"recursive method needs result type"**
â†’ Les fonctions rÃ©cursives ont besoin d'une annotation de type explicite

## ğŸ“š Ressources

- [Documentation officielle Scala 3](https://docs.scala-lang.org/scala3/)
- [Tour de Scala](https://docs.scala-lang.org/tour/tour-of-scala.html)
- [Scala Exercises](https://www.scala-exercises.org/)

## ğŸ‰ Bon courage !

Amusez-vous bien avec Scala et la programmation fonctionnelle ! ğŸš€

---

*Ce projet a Ã©tÃ© crÃ©Ã© pour la SÃ©ance 1 du cours de Programmation Fonctionnelle avec Scala.*


# SÃ©ance 2 - Collections immuables et Fonctions d'Ordre SupÃ©rieur

## ğŸ“š Objectifs d'apprentissage

- Manipuler les collections immuables (List, Map, Set)
- MaÃ®triser les fonctions d'ordre supÃ©rieur : map, flatMap, filter, fold, reduce, groupBy
- Comprendre la composition de fonctions
- Utiliser les fonctions anonymes et la curryification
- Construire un mini-projet : SystÃ¨me de Gestion de BibliothÃ¨que

## ğŸš€ Mise en route

### PrÃ©requis

- Java JDK 11 ou supÃ©rieur
- SBT (Scala Build Tool) installÃ©
- Avoir complÃ©tÃ© la SÃ©ance 1 (recommandÃ©)

### Installation

1. Clonez ou tÃ©lÃ©chargez ce projet
2. Ouvrez un terminal dans le dossier du projet
3. Lancez SBT avec la commande :
   ```bash
   sbt
   ```

### Commandes utiles

Dans le terminal SBT :

- `compile` - Compile le code
- `test` - Lance tous les tests
- `testOnly seance2.ExercicesSpec` - Lance uniquement les tests des exercices
- `console` - Ouvre le REPL Scala pour tester du code interactivement
- `~test` - Mode watch : relance les tests automatiquement Ã  chaque modification

Ou utilisez le script fourni :
```bash
./verifier.sh
```

## ğŸ“ Structure du projet

```
seance-2/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/scala/
â”‚   â”‚   â””â”€â”€ Exercices.scala    # âš ï¸ Fichier Ã  complÃ©ter (vos solutions)
â”‚   â””â”€â”€ test/scala/
â”‚       â””â”€â”€ ExercicesSpec.scala # ğŸ§ª Tests pour valider vos solutions
â”œâ”€â”€ build.sbt                   # Configuration du projet
â””â”€â”€ README.md                   # Ce fichier
```

## ğŸ¯ Instructions pour les exercices

### Ã‰tape 1 : Comprendre les exercices

Ouvrez le fichier `src/main/scala/Exercices.scala` et lisez attentivement :
- Les commentaires expliquant chaque exercice
- Les signatures de fonctions (types d'entrÃ©e et de sortie)
- Les exemples fournis

### Ã‰tape 2 : ComplÃ©ter les fonctions

Remplacez les `???` par votre code. 

**RÃ¨gles importantes :**
- âŒ N'utilisez PAS `var` (variables mutables)
- âœ… Utilisez uniquement `val` (valeurs immutables)
- âœ… PrivilÃ©giez les fonctions pures (sans effets de bord)
- âŒ Pas de `println` dans vos fonctions (sauf si explicitement demandÃ©)
- âœ… Utilisez les fonctions d'ordre supÃ©rieur (map, filter, etc.)

### Ã‰tape 3 : Tester votre code

Lancez les tests avec :
```bash
sbt test
# ou
./verifier.sh
```

Les tests vous indiqueront :
- âœ… Les exercices rÃ©ussis (en vert)
- âŒ Les exercices Ã  corriger (en rouge avec dÃ©tails)

### Ã‰tape 4 : ItÃ©rer

- Corrigez les erreurs
- Relancez les tests
- RÃ©pÃ©tez jusqu'Ã  ce que tous les tests passent ! ğŸ‰

## ğŸ“– Organisation des exercices

### Partie 1 : Collections de Base - List (4 exercices)
**Concepts :** CrÃ©ation, taille, head, contains

**Exercices :**
- `creerListe` : CrÃ©er une liste
- `tailleListe` : Obtenir la taille
- `premierElement` : Premier Ã©lÃ©ment avec Option
- `contient` : VÃ©rifier la prÃ©sence d'un Ã©lÃ©ment

### Partie 2 : map et filter (4 exercices)
**Concepts :** Transformation, filtrage, composition

**Exercices :**
- `doubler` : Transformer avec map
- `nombresEnChaines` : Conversion de types
- `filtrerPairs` : Filtrage
- `doublerPairs` : Composition map + filter

### Partie 3 : flatMap et for-comprehensions (3 exercices)
**Concepts :** Aplatissement, cartesian product

**Exercices :**
- `aplatir` : Flatten une liste de listes
- `dupliquer` : flatMap pour dupliquer
- `genererPaires` : for-comprehension

### Partie 4 : fold et reduce (4 exercices)
**Concepts :** AgrÃ©gation, rÃ©duction

**Exercices :**
- `somme` : Somme avec foldLeft
- `produit` : Produit avec foldLeft
- `concatener` : ConcatÃ©nation avec foldLeft
- `maximum` : Maximum avec reduceOption

### Partie 5 : OpÃ©rations avancÃ©es (4 exercices)
**Concepts :** groupBy, sortBy, distinct

**Exercices :**
- `grouperParParite` : Groupement
- `compterOccurrences` : Comptage avec groupBy
- `trierParLongueur` : Tri personnalisÃ©
- `eliminerDoublons` : DÃ©doublonnage

### Partie 6 : Mini-Projet - SystÃ¨me de Gestion de BibliothÃ¨que (10 exercices)
**Objectif :** Construire un systÃ¨me complet de gestion de bibliothÃ¨que

**Types utilisÃ©s :**
- `Livre` : Tuple (titre, auteur, annÃ©e, catÃ©gorie)
- `Emprunt` : Tuple (titre, emprunteur, estRendu)

**Exercices progressifs :**
1. `creerLivre` : CrÃ©er un livre
2. `extraireTitres` : Extraire les titres
3. `filtrerParCategorie` : Filtrer par catÃ©gorie
4. `filtrerParAuteur` : Filtrer par auteur
5. `livresRecents` : Filtrer par annÃ©e
6. `compterParCategorie` : Statistiques par catÃ©gorie
7. `grouperParAuteur` : Grouper par auteur
8. `livresNonRendus` : GÃ©rer les emprunts
9. `livresParEmprunteur` : Historique d'emprunts
10. `statistiquesBibliotheque` : Statistiques globales

### BONUS : Exercices AvancÃ©s (3 exercices optionnels)
Pour aller plus loin :
- `rechercherLivres` : Recherche multi-critÃ¨res
- `recommander` : SystÃ¨me de recommandation
- `emprunteurLePlusActif` : Analyse des emprunts

---

## ğŸ’¡ Astuces

### Utiliser le REPL
Le REPL (Read-Eval-Print Loop) est excellent pour tester des idÃ©es :
```bash
sbt console
```

Puis testez vos expressions :
```scala
scala> val liste = List(1, 2, 3, 4, 5)
scala> liste.map(_ * 2)
// res0: List[Int] = List(2, 4, 6, 8, 10)

scala> liste.filter(_ % 2 == 0)
// res1: List[Int] = List(2, 4)

scala> liste.map(_ * 2).filter(_ > 5)
// res2: List[Int] = List(6, 8, 10)
```

### Syntaxes Importantes

**map - Transformation :**
```scala
val nombres = List(1, 2, 3)
nombres.map(x => x * 2)           // List(2, 4, 6)
nombres.map(_ * 2)                 // Syntaxe courte
nombres.map(_.toString)            // List("1", "2", "3")
```

**filter - Filtrage :**
```scala
val nombres = List(1, 2, 3, 4, 5)
nombres.filter(x => x % 2 == 0)   // List(2, 4)
nombres.filter(_ > 2)              // List(3, 4, 5)
```

**flatMap - Aplatissement :**
```scala
val listes = List(List(1, 2), List(3, 4))
listes.flatten                     // List(1, 2, 3, 4)

val nombres = List(1, 2, 3)
nombres.flatMap(x => List(x, x))   // List(1, 1, 2, 2, 3, 3)
```

**for-comprehension :**
```scala
// Ã‰quivalent Ã  flatMap + map
for {
  i <- List(1, 2, 3)
  j <- List("a", "b")
} yield (i, j)
// List((1, "a"), (1, "b"), (2, "a"), (2, "b"), (3, "a"), (3, "b"))
```

**foldLeft - AgrÃ©gation :**
```scala
val nombres = List(1, 2, 3, 4)
nombres.foldLeft(0)(_ + _)         // 10 (somme)
nombres.foldLeft(1)(_ * _)         // 24 (produit)

// Forme explicite :
nombres.foldLeft(0)((acc, x) => acc + x)
```

**groupBy - Groupement :**
```scala
val nombres = List(1, 2, 3, 4, 5)
nombres.groupBy(_ % 2 == 0)
// Map(false -> List(1, 3, 5), true -> List(2, 4))

val mots = List("a", "ab", "abc", "abcd")
mots.groupBy(_.length)
// Map(1 -> List("a"), 2 -> List("ab"), 3 -> List("abc"), 4 -> List("abcd"))
```

### Concepts ClÃ©s

#### Fonctions d'Ordre SupÃ©rieur
Une fonction d'ordre supÃ©rieur est une fonction qui :
- Prend une ou plusieurs fonctions en paramÃ¨tre
- Retourne une fonction

```scala
// map est une fonction d'ordre supÃ©rieur
def map[A, B](liste: List[A], f: A => B): List[B]

// Exemple d'utilisation
val double = (x: Int) => x * 2
List(1, 2, 3).map(double)  // List(2, 4, 6)
```

#### Fonctions Anonymes
```scala
// Forme complÃ¨te
List(1, 2, 3).map(x => x * 2)

// Forme courte avec underscore
List(1, 2, 3).map(_ * 2)

// Avec plusieurs paramÃ¨tres
List(1, 2, 3).foldLeft(0)((acc, x) => acc + x)
List(1, 2, 3).foldLeft(0)(_ + _)
```

#### Composition de Fonctions
```scala
val nombres = List(1, 2, 3, 4, 5, 6)

// ChaÃ®nage d'opÃ©rations
nombres
  .filter(_ % 2 == 0)    // List(2, 4, 6)
  .map(_ * 3)            // List(6, 12, 18)
  .map(_.toString)       // List("6", "12", "18")
```

#### Option pour gÃ©rer l'absence de valeur
```scala
val liste = List(1, 2, 3)
liste.headOption           // Some(1)

val vide = List()
vide.headOption            // None

// Pattern matching sur Option
liste.headOption match {
  case Some(x) => s"Premier: $x"
  case None => "Liste vide"
}
```

#### ImmutabilitÃ© des Collections
```scala
val liste = List(1, 2, 3)
val nouvelle = liste.map(_ * 2)  // Nouvelle liste : List(2, 4, 6)
// liste reste inchangÃ©e : List(1, 2, 3)
```

## ğŸ“ Progression SuggÃ©rÃ©e

### Pour DÃ©butants (2-3h)
1. Partie 1 (Collections de base)
2. Partie 2 (map et filter)
3. Partie 4 (fold et reduce - exercices simples)

### Pour Niveau IntermÃ©diaire (3-4h)
Tout ce qui prÃ©cÃ¨de, plus :
- Partie 3 (flatMap)
- Partie 5 (OpÃ©rations avancÃ©es)
- Partie 6 (Mini-projet exercices 6.1 Ã  6.6)

### Pour Niveau AvancÃ© (4-5h)
Tout, y compris :
- Partie 6 complÃ¨te (Mini-projet)
- Exercices BONUS

## ğŸ“Š Validation

Votre objectif : **faire passer tous les tests** ! 

Lorsque vous verrez ceci, vous aurez rÃ©ussi :
```
[info] ExercicesSpec:
[info] - 1.1 - creerListe: crÃ©e une liste de 1 Ã  5 âœ“
[info] - 1.2 - tailleListe: retourne la taille d'une liste âœ“
[info] ... (tous les tests) âœ“
[info] All tests passed
```

## ğŸ¯ Le Mini-Projet : SystÃ¨me de Gestion de BibliothÃ¨que

Le point culminant de cette sÃ©ance est la **Partie 6**, oÃ¹ vous construirez progressivement un systÃ¨me de gestion de bibliothÃ¨que.

### Architecture

```
Livre = (String, String, Int, String)
  â†“
Emprunt = (String, String, Boolean)
  â†“
Fonctions:
  - CrÃ©er et gÃ©rer des livres
  - Filtrer par catÃ©gorie, auteur, annÃ©e
  - Calculer des statistiques
  - GÃ©rer les emprunts
  - Recommander des livres
```

### Exemple d'Utilisation

```scala
// CrÃ©er une bibliothÃ¨que
val livres = List(
  ("1984", "George Orwell", 1949, "Fiction"),
  ("Sapiens", "Yuval Harari", 2011, "Histoire"),
  ("Dune", "Frank Herbert", 1965, "Science-Fiction")
)

// Filtrer par catÃ©gorie
val fiction = filtrerParCategorie(livres, "Fiction")

// Compter par catÃ©gorie
val stats = compterParCategorie(livres)
// Map("Fiction" -> 1, "Histoire" -> 1, "Science-Fiction" -> 1)

// Livres rÃ©cents
val recents = livresRecents(livres, 2000)
// List(("Sapiens", "Yuval Harari", 2011, "Histoire"))
```

Ce mini-projet dÃ©montre :
- âœ… Manipulation intensive de collections
- âœ… Utilisation de map, filter, groupBy
- âœ… Composition de fonctions
- âœ… Pattern matching sur tuples
- âœ… Gestion de l'Option
- âœ… ImmutabilitÃ© totale

## ğŸ¤ Besoin d'aide ?

- Relisez les commentaires dans `Exercices.scala`
- Consultez les exemples dans la section "Astuces"
- Utilisez le REPL pour expÃ©rimenter : `sbt console`
- Lisez les messages d'erreur attentivement
- N'hÃ©sitez pas Ã  demander de l'aide Ã  votre enseignant

### Erreurs Courantes

**"not found: value ???"**
â†’ Vous n'avez pas encore remplacÃ© le `???` par votre code

**"value map is not a member of..."**
â†’ VÃ©rifiez que vous travaillez bien avec une collection (List, etc.)

**"missing parameter type"**
â†’ Parfois Scala a besoin du type explicite : `(x: Int) => x * 2`

**"type mismatch"**
â†’ VÃ©rifiez que votre fonction retourne le bon type

**"reduceLeftOption on empty: List"**
â†’ Utilisez `reduceOption` ou `foldLeft` avec une valeur initiale

## ğŸ“š Ressources

- [Documentation officielle Scala 3](https://docs.scala-lang.org/scala3/)
- [Collections Scala](https://docs.scala-lang.org/overviews/collections-2.13/introduction.html)
- [Tour de Scala - Collections](https://docs.scala-lang.org/tour/unified-types.html)
- [Scala Exercises](https://www.scala-exercises.org/)

## ğŸ‰ Bon courage !

Amusez-vous bien avec les collections et les fonctions d'ordre supÃ©rieur ! ğŸš€

---

*Ce projet a Ã©tÃ© crÃ©Ã© pour la SÃ©ance 2 du cours de Programmation Fonctionnelle avec Scala.*


# SÃ©ance 3 : Gestion des erreurs et types fonctionnels

## ğŸ¯ Objectifs

Dans cette sÃ©ance, vous allez apprendre Ã  :
- GÃ©rer les erreurs de maniÃ¨re fonctionnelle
- Utiliser `Option[T]`, `Try[T]`, et `Either[L, R]`
- Composer des opÃ©rations avec map/flatMap
- ImplÃ©menter un systÃ¨me de validation robuste

## ğŸ“š Contenu

### Partie 1 : Motivation (10-15 min)
Pourquoi Ã©viter `null` et les exceptions ?

### Partie 2 : Option[T] (30-40 min)
ReprÃ©senter l'absence de valeur : `Some` / `None`
- **7 exercices**

### Partie 3 : Try[T] (25-30 min)
GÃ©rer les exceptions de maniÃ¨re fonctionnelle : `Success` / `Failure`
- **6 exercices**

### Partie 4 : Either[L, R] (25-30 min)
GÃ©rer les erreurs avec des messages explicites : `Left` / `Right`
- **5 exercices**

### Partie 5 : Mini-Projet (50-60 min)
**SystÃ¨me de gestion de commandes en ligne**
- Validation multi-niveaux
- Parsing de donnÃ©es
- Statistiques
- **8 exercices + 3 BONUS**

## ğŸš€ DÃ©marrage rapide

### 1. Compiler le projet

```bash
sbt compile
```

### 2. Lancer les tests

```bash
# Tester vos solutions
sbt test

# Ou spÃ©cifiquement
sbt "testOnly seance3.ExercicesSpec"
```

### 3. Utiliser le REPL

```bash
sbt console
```

### 4. VÃ©rification rapide

```bash
./verifier.sh
```

## ğŸ“ Exercices

ComplÃ©tez les fonctions dans `src/main/scala/Exercices.scala`.

**Total : 33 exercices** rÃ©partis en 6 parties.

### Comment travailler ?

1. **Lisez** les commentaires dans `Exercices.scala`
2. **Remplacez** les `???` par votre implÃ©mentation
3. **Testez** avec `sbt test`
4. **ItÃ©rez** jusqu'Ã  ce que tous les tests passent

## ğŸ’¡ Concepts clÃ©s

### Option[T]
```scala
val some: Option[Int] = Some(42)
val none: Option[Int] = None

// Transformation
some.map(_ * 2)              // Some(84)
some.getOrElse(0)            // 42
none.getOrElse(0)            // 0
```

### Try[T]
```scala
import scala.util.Try

val success: Try[Int] = Try("42".toInt)   // Success(42)
val failure: Try[Int] = Try("abc".toInt)  // Failure(...)

// RÃ©cupÃ©ration
failure.recover { case _ => 0 }  // Success(0)
```

### Either[L, R]
```scala
val right: Either[String, Int] = Right(42)
val left: Either[String, Int] = Left("Error")

// Transformation
right.map(_ * 2)  // Right(84)
left.map(_ * 2)   // Left("Error")
```

## â±ï¸ Timing suggÃ©rÃ©

- Partie 2 (Option) : 35-45 min
- Partie 3 (Try) : 30-35 min
- Partie 4 (Either) : 30-35 min
- Partie 5 (Mini-Projet) : 50-60 min

**Total : 2h30-3h**

## ğŸ¯ Mini-Projet

Le mini-projet simule un systÃ¨me de e-commerce avec :

### ModÃ¨les
- **Product** : id, nom, prix, stock
- **Customer** : id, nom, email, limite de crÃ©dit
- **Order** : client + items (produit + quantitÃ©)

### RÃ¨gles mÃ©tier
âœ“ VÃ©rifier l'existence du client  
âœ“ VÃ©rifier la disponibilitÃ© des produits  
âœ“ ContrÃ´ler le stock  
âœ“ Respecter la limite de crÃ©dit  

### FonctionnalitÃ©s
- Validation complÃ¨te des commandes
- Parsing de donnÃ©es textuelles
- Statistiques (revenu, meilleur client, top produits)

## âœ… CritÃ¨res de rÃ©ussite

Ã€ la fin de la sÃ©ance, vous devez :

âœ“ Comprendre les problÃ¨mes de null et des exceptions  
âœ“ MaÃ®triser Option, Try, Either  
âœ“ Utiliser map/flatMap pour composer  
âœ“ ImplÃ©menter un systÃ¨me de validation robuste  
âœ“ Composer des opÃ©rations pouvant Ã©chouer  

## ğŸ“– Ressources

- [Documentation Scala - Option](https://www.scala-lang.org/api/current/scala/Option.html)
- [Documentation Scala - Try](https://www.scala-lang.org/api/current/scala/util/Try.html)
- [Documentation Scala - Either](https://www.scala-lang.org/api/current/scala/util/Either.html)

## ğŸ’¬ Aide

Si vous Ãªtes bloquÃ© :

1. **Lisez les types** : Ils vous guident vers la solution
2. **Testez dans le REPL** : `sbt console`
3. **Lisez les messages d'erreur** : Ils sont informatifs
4. **MaÃ®trisez map/flatMap** : Essentiels pour composer les opÃ©rations
5. **Demandez de l'aide** : Ã€ votre enseignant ou vos camarades

## ğŸš§ Erreurs courantes

âŒ Utiliser `.get` sans vÃ©rification  
âŒ Oublier `flatMap` (crÃ©er `Option[Option[T]]`)  
âŒ Confondre `map` et `flatMap`  

âœ… Toujours utiliser `getOrElse` ou pattern matching  
âœ… Utiliser `flatMap` pour composer  
âœ… Garder les types cohÃ©rents  

---

**Bon courage ! ğŸ“**


# SÃ©ance 4 : For-comprehension et consolidation

## ğŸ¯ Objectifs

Dans cette sÃ©ance, vous allez :
- Apprendre la **for-comprehension** : syntaxe Ã©lÃ©gante pour composer des opÃ©rations
- **RÃ©viser et consolider** tous les concepts des sÃ©ances prÃ©cÃ©dentes
- **SynthÃ©tiser** vos acquis dans un mini-projet

## ğŸ“š Contenu

### Partie 1 : For-comprehension (35-45 min)
Introduction Ã  la syntaxe for-comprehension comme alternative Ã©lÃ©gante Ã  map/flatMap
- **8 exercices**

### Partie 2 : RÃ©vision HOFs (30-35 min)
RÃ©vision des Higher-Order Functions (map, filter, flatMap, fold, groupBy)
- **5 exercices**

### Partie 3 : RÃ©vision Option/Try/Either (30-35 min)
Composition de types fonctionnels avec for-comprehension
- **6 exercices**

### Partie 4 : Mini-Projet - Gestionnaire de tÃ¢ches (45-55 min)
**Projet de synthÃ¨se** : un gestionnaire de tÃ¢ches (TODO list) qui combine tous les concepts
- **11 exercices + BONUS**

## âš¡ For-comprehension en bref

### C'est quoi ?

La for-comprehension est du **sucre syntaxique** pour simplifier l'Ã©criture de map/flatMap imbriquÃ©s.

```scala
// Avec flatMap/map (sÃ©ance 3)
a.flatMap(x => b.map(y => x + y))

// Avec for-comprehension (sÃ©ance 4) - Ã©quivalent !
for {
  x <- a
  y <- b
} yield x + y
```

### Pourquoi c'est utile ?

```scala
// Version imbriquÃ©e (difficile Ã  lire)
a.flatMap(x => 
  b.flatMap(y => 
    c.map(z => 
      x + y + z
    )
  )
)

// Version for-comprehension (clair et lisible)
for {
  x <- a
  y <- b
  z <- c
} yield x + y + z
```

### Syntaxe de base

```scala
// 1. Avec Option
for {
  x <- Some(5)
  y <- Some(10)
} yield x + y
// Some(15)

// 2. Avec Either
for {
  name <- validateName("Alice")
  email <- validateEmail("alice@ex.com")
} yield User(name, email)
// Right(User(...))

// 3. Avec Try
for {
  a <- Try("5".toInt)
  b <- Try("10".toInt)
} yield a + b
// Success(15)

// 4. Avec valeurs intermÃ©diaires
for {
  price <- Some(100.0)
  discount <- Some(0.2)
  discountAmount = price * discount  // = au lieu de <-
  finalPrice = price - discountAmount
} yield finalPrice
// Some(80.0)
```

## ğŸ“¦ ModÃ¨les de donnÃ©es

Le mini-projet utilise ce modÃ¨le :

```scala
case class Task(
  id: Int,
  title: String,
  completed: Boolean,
  priority: Int  // 1 = haute, 2 = moyenne, 3 = basse
)
```

## â±ï¸ Timing suggÃ©rÃ©

- Partie 1 (For-comprehension) : 35-45 min
- Partie 2 (RÃ©vision HOFs) : 30-35 min
- Partie 3 (RÃ©vision Option/Try/Either) : 30-35 min
- Partie 4 (Mini-Projet) : 45-55 min

**Total : 2h30-3h**

## âœ… CritÃ¨res de rÃ©ussite

Ã€ la fin de la sÃ©ance, vous devez :

âœ“ Comprendre ce qu'est une for-comprehension  
âœ“ Savoir la traduire en map/flatMap  
âœ“ MaÃ®triser les HOFs (rÃ©vision)  
âœ“ Composer Option/Try/Either avec Ã©lÃ©gance  
âœ“ SynthÃ©tiser tous les concepts dans le mini-projet  

## ğŸ’¬ Aide

Si vous Ãªtes bloquÃ© :

1. **Pour for-comprehension** : Ã‰crivez d'abord avec map/flatMap, puis convertissez
2. **Pour les HOFs** : Relisez la SÃ©ance 2
3. **Pour Option/Try/Either** : Relisez la SÃ©ance 3
4. **Testez dans le REPL** : `sbt console`
5. **Demandez de l'aide** : Ã€ votre enseignant ou vos camarades

## ğŸš§ Erreurs courantes

âŒ Confondre `<-` et `=` dans for-comprehension  
âŒ Oublier le `yield` Ã  la fin  
âŒ MÃ©langer des types incompatibles (Option avec Either, etc.)  
âŒ Penser que for-comprehension est une boucle (c'est pas le cas !)  

âœ… `<-` pour extraire une valeur, `=` pour une valeur intermÃ©diaire  
âœ… Toujours finir par `yield` pour retourner une valeur  
âœ… Garder le mÃªme type dans toute la for-comprehension  
âœ… C'est du sucre syntaxique pour map/flatMap  

---

**Bon courage ! Cette sÃ©ance consolide tout ce que vous avez appris ! ğŸ“**


# ğŸ“ SÃ©ance 5 : Parsing JSON avec Circe

## ğŸ¯ Objectifs

Cette sÃ©ance vous permet de :
- Apprendre Ã  parser du JSON avec la bibliothÃ¨que **Circe**
- CrÃ©er des **case classes** appropriÃ©es pour modÃ©liser des donnÃ©es
- GÃ©rer les **erreurs de parsing** avec `Either` et `Try`
- **Lire** et **Ã©crire** des fichiers JSON
- CrÃ©er des **pipelines ETL** simples (Extract-Transform-Load)

## ğŸ“š Contenu

La sÃ©ance contient **20 exercices** rÃ©partis en 6 parties :

### Partie 1 : Parsing JSON basique (3 exercices)
- Parser un objet simple
- Parser des objets avec champs optionnels (`Option`)
- Parser des listes d'objets

### Partie 2 : Gestion des erreurs (3 exercices)
- Utiliser `Try` pour capturer les exceptions
- Parser ET valider les donnÃ©es
- Parser plusieurs objets et compter les erreurs

### Partie 3 : Lecture de fichiers (3 exercices)
- Lire un fichier JSON et le parser
- Lire des listes depuis des fichiers
- Compter les objets valides

### Partie 4 : Ã‰criture de fichiers (4 exercices)
- Convertir des objets en JSON
- Convertir des listes en JSON
- Ã‰crire du JSON dans des fichiers

### Partie 5 : Pipelines ETL (3 exercices)
- Lire â†’ Transformer â†’ Ã‰crire
- Filtrer des donnÃ©es
- AgrÃ©ger et exporter des statistiques

### Partie 6 : Validation et nettoyage (4 exercices)
- Valider et filtrer des donnÃ©es
- Nettoyer des fichiers
- GÃ©nÃ©rer des rapports de traitement

## ğŸš€ DÃ©marrage rapide

### 1. Compiler le projet

```bash
sbt compile
```

### 2. Lancer les tests

```bash
sbt test
```

Les tests des `Exercices` vont Ã©chouer car vous devez les implÃ©menter ! 
Les tests des `Solutions` passent tous.

### 3. Mode watch (recompile automatiquement)

```bash
sbt ~test
```

## ğŸ“– Circe - Guide rapide

### Imports nÃ©cessaires

```scala
import io.circe._
import io.circe.generic.auto._  // DÃ©rivation automatique
import io.circe.parser._         // Fonctions de parsing
import io.circe.syntax._         // Conversion vers JSON
```

### Parser du JSON

```scala
import io.circe.parser.decode
import io.circe.generic.auto._

case class Person(name: String, age: Int)

// Parser une chaÃ®ne JSON
val json = """{"name":"Alice","age":25}"""
val result: Either[Error, Person] = decode[Person](json)

result match {
  case Right(person) => println(s"SuccÃ¨s : $person")
  case Left(error) => println(s"Erreur : ${error.getMessage}")
}
```

### GÃ©nÃ©rer du JSON

```scala
import io.circe.syntax._
import io.circe.generic.auto._

case class Person(name: String, age: Int)

val person = Person("Alice", 25)
val json: String = person.asJson.spaces2  // Avec indentation
println(json)
// {
//   "name" : "Alice",
//   "age" : 25
// }
```

### Champs optionnels

```scala
case class User(
  name: String,
  age: Option[Int]  // Peut Ãªtre absent dans le JSON
)

// JSON avec age
val json1 = """{"name":"Alice","age":25}"""
decode[User](json1)  // Right(User("Alice", Some(25)))

// JSON sans age
val json2 = """{"name":"Bob"}"""
decode[User](json2)  // Right(User("Bob", None))
```

### Lire un fichier JSON

```scala
import scala.io.Source
import scala.util.Try

def readJsonFile(filename: String): Either[String, Person] = {
  Try {
    val source = Source.fromFile(filename)
    val content = source.mkString
    source.close()
    content
  } match {
    case Success(content) =>
      decode[Person](content) match {
        case Right(person) => Right(person)
        case Left(error) => Left(s"Parsing error: ${error.getMessage}")
      }
    case Failure(exception) =>
      Left(s"File error: ${exception.getMessage}")
  }
}
```

### Ã‰crire un fichier JSON

```scala
import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets

def writeJsonFile(person: Person, filename: String): Either[String, Unit] = {
  Try {
    val json = person.asJson.spaces2
    Files.write(Paths.get(filename), json.getBytes(StandardCharsets.UTF_8))
  } match {
    case Success(_) => Right(())
    case Failure(exception) => Left(s"Write error: ${exception.getMessage}")
  }
}
```

## ğŸ’¡ Conseils

1. **Commencez par les exercices simples** (Partie 1) pour comprendre Circe
2. **Testez chaque fonction** au fur et Ã  mesure
3. **Lisez les messages d'erreur** de Circe, ils sont trÃ¨s informatifs
4. **Utilisez le mode watch** (`sbt ~test`) pour voir les tests passer en temps rÃ©el
5. **N'oubliez pas les imports** ! Circe nÃ©cessite plusieurs imports

## ğŸ“ PrÃ©paration au projet final

Cette sÃ©ance vous prÃ©pare directement au **projet final** oÃ¹ vous devrez :
- Parser des fichiers JSON rÃ©els (pays, joueurs de foot, films, etc.)
- GÃ©rer des donnÃ©es bruitÃ©es (erreurs, champs manquants)
- Transformer et agrÃ©ger des donnÃ©es
- Exporter des rÃ©sultats en JSON

Les compÃ©tences que vous apprenez ici sont **essentielles** pour rÃ©ussir le projet !

## ğŸ“Š Progression

Voici combien d'exercices vous devez complÃ©ter :

- âœ… **Minimum** : 15/20 exercices (Parties 1-4)
- ğŸ¯ **Objectif** : 18/20 exercices (+ Partie 5)
- ğŸŒŸ **Excellent** : 20/20 exercices (toutes les parties)

## â±ï¸ DurÃ©e estimÃ©e

- **Partie 1-2** : 45 minutes (parsing basique + erreurs)
- **Partie 3-4** : 1h (fichiers)
- **Partie 5-6** : 1h45 (pipelines + validation)
- **Total** : ~3h30

## ğŸ†˜ Besoin d'aide ?

1. **Consultez le guide Circe** : https://circe.github.io/circe/
2. **Lisez les commentaires** dans `Exercices.scala`
3. **Regardez les tests** pour comprendre ce qui est attendu
4. **Demandez au professeur** !

---

**Bon courage ! ğŸš€**


# ğŸš€ SÃ©ance 6 : Mini-ETL GuidÃ© - Analyse de Restaurants

## ğŸ¯ Objectif

CrÃ©er votre premier **pipeline ETL complet** from scratch ! Vous allez :
- âœ… Parser des donnÃ©es JSON (restaurants)
- âœ… Nettoyer et valider les donnÃ©es
- âœ… Calculer des statistiques
- âœ… GÃ©nÃ©rer un rapport JSON

**Ceci est votre rÃ©pÃ©tition gÃ©nÃ©rale avant le projet final !**

## ğŸ“Š Les donnÃ©es

Vous avez 2 fichiers dans le dossier `data/` :

### `restaurants_clean.json` (10 restaurants)
DonnÃ©es parfaites pour commencer.

### `restaurants_dirty.json` (12 restaurants avec erreurs)
DonnÃ©es rÃ©alistes avec :
- Noms vides
- Ratings invalides (< 0 ou > 5)
- Prix hors limites
- Champs manquants
- Villes vides

## ğŸ“ Structure d'un restaurant

```scala
case class Restaurant(
  id: Int,
  name: String,
  cuisine: String,
  rating: Double,       // Entre 0 et 5
  priceRange: Int,      // 1 (â‚¬) Ã  4 (â‚¬â‚¬â‚¬â‚¬)
  city: String,
  vegetarianOptions: Boolean
)
```

## ğŸ¯ Mission : CrÃ©er un rapport d'analyse

Votre pipeline doit gÃ©nÃ©rer un fichier `results.json` contenant :

```json
{
  "statistics": {
    "totalRestaurants": 10,
    "averageRating": 4.44,
    "vegetarianFriendlyCount": 8
  },
  "topRated": [
    {"name": "Vegan Delight", "rating": 4.9},
    {"name": "Sushi Master", "rating": 4.8}
  ],
  "byCuisine": {
    "French": 2,
    "Japanese": 1,
    "Italian": 1
  },
  "byPriceRange": {
    "1": 2,
    "2": 4,
    "3": 2,
    "4": 2
  }
}
```

---

## ğŸ“š Guide Ã©tape par Ã©tape

### Ã‰tape 1 : CrÃ©er les case classes

CrÃ©ez le fichier `src/main/scala/Restaurant.scala` :

```scala
package miniEtl

// TODO: CrÃ©er la case class Restaurant avec tous les champs

// TODO: CrÃ©er RestaurantStats avec :
//   - totalRestaurants: Int
//   - averageRating: Double
//   - vegetarianFriendlyCount: Int

// TODO: CrÃ©er TopRestaurant avec :
//   - name: String
//   - rating: Double

// TODO: CrÃ©er AnalysisReport avec :
//   - statistics: RestaurantStats
//   - topRated: List[TopRestaurant]
//   - byCuisine: Map[String, Int]
//   - byPriceRange: Map[String, Int]
```

**ğŸ’¡ Conseil** : VÃ©rifiez que les noms de champs correspondent exactement au JSON !

### Ã‰tape 2 : Lire le fichier JSON

CrÃ©ez `src/main/scala/DataLoader.scala` :

```scala
package miniEtl

import io.circe._
import io.circe.generic.auto._
import io.circe.parser._
import scala.io.Source
import scala.util.{Try, Success, Failure}

object DataLoader {

  /**
   * Lit un fichier JSON et parse les restaurants
   */
  def loadRestaurants(filename: String): Either[String, List[Restaurant]] = {
    // TODO: Utiliser Try pour lire le fichier
    //   1. CrÃ©er un Source.fromFile(filename)
    //   2. Lire le contenu avec source.mkString
    //   3. Fermer le fichier avec source.close() - IMPORTANT !
    //   4. Parser avec decode[List[Restaurant]](content)
    //   5. GÃ©rer les erreurs avec pattern matching
    ???
  }
}
```

**ğŸ’¡ Indices** :
- Utilisez `decode[List[Restaurant]](jsonString)` pour parser
- Pensez Ã  fermer le fichier avec `source.close()`
- GÃ©rez 2 types d'erreurs : lecture de fichier ET parsing JSON

### Ã‰tape 3 : Valider les donnÃ©es

CrÃ©ez `src/main/scala/DataValidator.scala` :

```scala
package miniEtl

object DataValidator {

  /**
   * Valide un restaurant selon les rÃ¨gles mÃ©tier
   */
  def isValid(restaurant: Restaurant): Boolean = {
    // TODO: VÃ©rifier que :
    //   - name est non vide
    //   - cuisine est non vide
    //   - rating est entre 0.0 et 5.0
    //   - priceRange est entre 1 et 4
    //   - city est non vide
    ???
  }

  /**
   * Filtre les restaurants valides
   */
  def filterValid(restaurants: List[Restaurant]): List[Restaurant] = {
    // TODO: Utiliser filter avec isValid
    ???
  }
}
```

**ğŸ’¡ Astuce** : Utilisez `&&` pour combiner les conditions

### Ã‰tape 4 : Calculer les statistiques

CrÃ©ez `src/main/scala/StatsCalculator.scala` :

```scala
package miniEtl

object StatsCalculator {

  /**
   * Calcule les statistiques gÃ©nÃ©rales
   */
  def calculateStats(restaurants: List[Restaurant]): RestaurantStats = {
    // TODO: Calculer :
    //   - total : taille de la liste
    //   - avgRating : somme des ratings / nombre de restaurants
    //   - vegCount : compter ceux avec vegetarianOptions = true
    // ATTENTION : gÃ©rer le cas liste vide pour Ã©viter division par 0 !
    ???
  }

  /**
   * Top N restaurants par note
   */
  def topRated(restaurants: List[Restaurant], n: Int = 3): List[TopRestaurant] = {
    // TODO: 
    //   1. Trier par rating dÃ©croissant (utiliser sortBy avec -)
    //   2. Prendre les n premiers (take)
    //   3. Mapper vers TopRestaurant
    ???
  }

  /**
   * Compte par type de cuisine
   */
  def countByCuisine(restaurants: List[Restaurant]): Map[String, Int] = {
    // TODO: 
    //   1. Grouper par cuisine (groupBy)
    //   2. Compter la taille de chaque groupe (map)
    ???
  }

  /**
   * Compte par gamme de prix
   */
  def countByPriceRange(restaurants: List[Restaurant]): Map[String, Int] = {
    // TODO: Comme countByCuisine mais grouper par priceRange
    // ATTENTION : convertir priceRange en String pour la Map
    ???
  }
}
```

**ğŸ’¡ Rappels HOFs** :
- `groupBy(_.field)` : Regroupe par un champ
- `sortBy(-_.field)` : Trie par ordre dÃ©croissant
- `map(r => TopRestaurant(r.name, r.rating))` : Transforme

### Ã‰tape 5 : GÃ©nÃ©rer le rapport

CrÃ©ez `src/main/scala/ReportGenerator.scala` :

```scala
package miniEtl

import io.circe._
import io.circe.generic.auto._
import io.circe.syntax._
import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets
import scala.util.Try

object ReportGenerator {

  /**
   * GÃ©nÃ¨re le rapport complet
   */
  def generateReport(restaurants: List[Restaurant]): AnalysisReport = {
    // TODO: CrÃ©er un AnalysisReport en utilisant StatsCalculator
    //   - statistics = StatsCalculator.calculateStats(...)
    //   - topRated = StatsCalculator.topRated(..., 3)
    //   - byCuisine = StatsCalculator.countByCuisine(...)
    //   - byPriceRange = StatsCalculator.countByPriceRange(...)
    ???
  }

  /**
   * Ã‰crit le rapport en JSON
   */
  def writeReport(report: AnalysisReport, filename: String): Either[String, Unit] = {
    // TODO: 
    //   1. Convertir en JSON : report.asJson.spaces2
    //   2. Ã‰crire dans le fichier avec Files.write
    //   3. GÃ©rer les erreurs avec Try
    ???
  }
}
```

**ğŸ’¡ Astuce** : 
- `report.asJson.spaces2` : Convertit en JSON avec indentation
- `Files.write(Paths.get(filename), json.getBytes(StandardCharsets.UTF_8))` : Ã‰crit

### Ã‰tape 6 : Assembler le pipeline

CrÃ©ez `src/main/scala/Main.scala` :

```scala
package miniEtl

object Main extends App {

  println("Mini-ETL : Analyse de Restaurants\n")

  // TODO: CrÃ©er le pipeline ETL avec for-comprehension
  val result = for {
    // TODO: 1. Charger les restaurants avec DataLoader
    restaurants <- ??? // DataLoader.loadRestaurants("data/restaurants_dirty.json")
    _ = println(s"${restaurants.length} restaurants chargÃ©s")
    
    // TODO: 2. Valider et filtrer avec DataValidator
    validRestaurants = ??? // DataValidator.filterValid(...)
    _ = println(s"${validRestaurants.length} restaurants valides")
    
    // TODO: 3. GÃ©nÃ©rer le rapport avec ReportGenerator
    report = ??? // ReportGenerator.generateReport(...)
    _ = println(s"Rapport gÃ©nÃ©rÃ©")
    
    // TODO: 4. Ã‰crire le rapport
    _ <- ??? // ReportGenerator.writeReport(report, "results.json")
    _ = println(s"Rapport Ã©crit dans results.json")
    
  } yield report

  // TODO: Pattern matching sur result
  //   - Si Right(report) : Afficher les statistiques
  //   - Si Left(error) : Afficher l'erreur
  result match {
    case Right(report) =>
      println("\n STATISTIQUES")
      println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
      // TODO: Afficher report.statistics.totalRestaurants
      // TODO: Afficher report.statistics.averageRating (avec f"${...}%.2f")
      // TODO: Afficher report.statistics.vegetarianFriendlyCount
      
      println("\n TOP 3 RESTAURANTS")
      println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
      // TODO: Afficher report.topRated avec zipWithIndex
      
      println("\n PAR TYPE DE CUISINE")
      println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
      // TODO: Afficher report.byCuisine (trier par count dÃ©croissant)
      
      println("\n PAR GAMME DE PRIX")
      println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
      // TODO: Afficher report.byPriceRange
      
      println("\n Pipeline ETL terminÃ© avec succÃ¨s !")
      
    case Left(error) =>
      // TODO: Afficher l'erreur et quitter
      ???
  }
}
```

**ğŸ’¡ Rappels** :
- Dans for-comprehension : `=` pour calculs, `<-` pour Either
- `_` pour les effets de bord (println)
- `f"${variable}%.2f"` pour formatter avec 2 dÃ©cimales

---

## ğŸš€ Lancer le projet

### 1. Compiler

```bash
sbt compile
```

Si Ã§a compile, vous Ãªtes sur la bonne voie !

### 2. ExÃ©cuter

```bash
sbt run
```

### 3. VÃ©rifier le rÃ©sultat

Le fichier `results.json` doit Ãªtre crÃ©Ã© Ã  la racine du projet.

---

## âœ… Checklist

- [ ] Tous les fichiers sont crÃ©Ã©s
- [ ] Le projet compile sans erreur
- [ ] Le programme s'exÃ©cute et affiche les statistiques
- [ ] Le fichier `results.json` est gÃ©nÃ©rÃ©
- [ ] Les donnÃ©es invalides sont bien filtrÃ©es (5 rejetÃ©s sur 12)

## ğŸš¨ Points d'attention

1. **Imports Circe** : N'oubliez pas dans chaque fichier :
   ```scala
   import io.circe._
   import io.circe.generic.auto._
   import io.circe.parser._
   import io.circe.syntax._
   ```

2. **Fermeture des fichiers** : Toujours `source.close()`

3. **Gestion des listes vides** : 
   ```scala
   if (restaurants.nonEmpty) somme / total else 0.0
   ```

4. **For-comprehension** : 
   - `restaurants <- load()` : extrait de Either
   - `filtered = validate()` : simple assignation
   - `_ = println()` : effet de bord

## ğŸ’¡ Conseils

- **Testez petit** : Compilez aprÃ¨s chaque fichier
- **Commencez simple** : Testez avec `restaurants_clean.json` d'abord
- **Lisez les erreurs** : Circe donne des messages trÃ¨s dÃ©taillÃ©s
- **Console interactive** : Testez vos fonctions avec `sbt console`
- **Demandez de l'aide** : C'est pour Ã§a que le professeur est lÃ  !

## ğŸ¯ RÃ©sultat attendu

Votre programme doit afficher quelque chose comme :

```
ğŸš€ Mini-ETL : Analyse de Restaurants

âœ… 12 restaurants chargÃ©s
âœ… 7 restaurants valides (5 rejetÃ©s)
âœ… Rapport gÃ©nÃ©rÃ©
âœ… Rapport Ã©crit dans results.json

ğŸ“Š STATISTIQUES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total restaurants     : 7
Note moyenne          : 4.61/5
Options vÃ©gÃ©tariennes : 7

ğŸ† TOP 3 RESTAURANTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Vegan Delight (4.9/5)
2. Sushi Master (4.8/5)
3. La Brasserie (4.7/5)

ğŸ½ï¸  PAR TYPE DE CUISINE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Japanese: 2
French: 2
Chinese: 1
Indian: 1
Vegan: 1

ğŸ’° PAR GAMME DE PRIX
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â‚¬â‚¬ (2): 4 restaurants
â‚¬â‚¬â‚¬ (3): 2 restaurants
â‚¬â‚¬â‚¬â‚¬ (4): 1 restaurants

âœ… Pipeline ETL terminÃ© avec succÃ¨s !
```

---

**Bon courage ! C'est votre derniÃ¨re prÃ©paration avant le projet final ! ğŸš€**
